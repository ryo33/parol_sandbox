// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolSandboxGrammarTrait<'t> {
    /// Semantic action for non-terminal 'ParolSandbox'
    fn parol_sandbox(&mut self, _arg: &ParolSandbox<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'String'
    fn string(&mut self, _arg: &String<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'A'
    fn a(&mut self, _arg: &A<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'B'
    fn b(&mut self, _arg: &B<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'C'
    fn c(&mut self, _arg: &C<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringWrapper'
    fn string_wrapper(&mut self, _arg: &StringWrapper<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 3
///
/// StringListGroup: A;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StringListGroup0<'t> {
    pub a: Box<A<'t>>,
}

///
/// Type derived for production 4
///
/// StringListGroup: B;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StringListGroup1<'t> {
    pub b: Box<B<'t>>,
}

///
/// Type derived for production 5
///
/// StringListGroup: C;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StringListGroup2<'t> {
    pub c: Box<C<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal A
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct A<'t> {
    pub a: Token<'t>, /* a */
}

///
/// Type derived for non-terminal B
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct B<'t> {
    pub b: Token<'t>, /* b */
}

///
/// Type derived for non-terminal C
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct C<'t> {
    pub c: Token<'t>, /* c */
}

///
/// Type derived for non-terminal ParolSandbox
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandbox<'t> {
    pub string: Box<String<'t>>,
}

///
/// Type derived for non-terminal String
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct String<'t> {
    pub string_list: Vec<StringList<'t>>,
}

///
/// Type derived for non-terminal StringList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StringList<'t> {
    pub string_list_group: Box<StringListGroup<'t>>,
}

///
/// Type derived for non-terminal StringListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StringListGroup<'t> {
    StringListGroup0(StringListGroup0<'t>),
    StringListGroup1(StringListGroup1<'t>),
    StringListGroup2(StringListGroup2<'t>),
}

///
/// Type derived for non-terminal StringWrapper
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StringWrapper<'t> {
    pub string_wrapper: Token<'t>, /* " */
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    A(A<'t>),
    B(B<'t>),
    C(C<'t>),
    ParolSandbox(ParolSandbox<'t>),
    String(String<'t>),
    StringList(Vec<StringList<'t>>),
    StringListGroup(StringListGroup<'t>),
    StringWrapper(StringWrapper<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolSandboxGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolSandboxGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolSandboxGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// ParolSandbox: String;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox(
        &mut self,
        _string: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string = pop_item!(self, string, String, context);
        let parol_sandbox_built = ParolSandboxBuilder::default()
            .string(Box::new(string))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parol_sandbox(&parol_sandbox_built)?;
        self.push(ASTType::ParolSandbox(parol_sandbox_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// String: /"/^ /* Clipped */ %push(String) StringList /* Vec */ StringWrapper^ /* Clipped */ %pop();
    ///
    #[parol_runtime::function_name::named]
    fn string(
        &mut self,
        _string_wrapper: &ParseTreeStackEntry<'t>,
        _string_list: &ParseTreeStackEntry<'t>,
        _string_wrapper0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        // Ignore clipped member 'string_wrapper0'
        self.pop(context);
        let string_list = pop_and_reverse_item!(self, string_list, StringList, context);
        let string_built = StringBuilder::default()
            // Ignore clipped member 'string_wrapper'
            .string_list(string_list)
            // Ignore clipped member 'string_wrapper0'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string(&string_built)?;
        self.push(ASTType::String(string_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// StringList /* Vec<T>::Push */: StringListGroup StringList;
    ///
    #[parol_runtime::function_name::named]
    fn string_list_0(
        &mut self,
        _string_list_group: &ParseTreeStackEntry<'t>,
        _string_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut string_list = pop_item!(self, string_list, StringList, context);
        let string_list_group = pop_item!(self, string_list_group, StringListGroup, context);
        let string_list_0_built = StringListBuilder::default()
            .string_list_group(Box::new(string_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        string_list.push(string_list_0_built);
        self.push(ASTType::StringList(string_list), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// StringListGroup: A;
    ///
    #[parol_runtime::function_name::named]
    fn string_list_group_0(
        &mut self,
        _a: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a = pop_item!(self, a, A, context);
        let string_list_group_0_built = StringListGroup0Builder::default()
            .a(Box::new(a))
            .build()
            .into_diagnostic()?;
        let string_list_group_0_built =
            StringListGroup::StringListGroup0(string_list_group_0_built);
        self.push(ASTType::StringListGroup(string_list_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// StringListGroup: B;
    ///
    #[parol_runtime::function_name::named]
    fn string_list_group_1(
        &mut self,
        _b: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = pop_item!(self, b, B, context);
        let string_list_group_1_built = StringListGroup1Builder::default()
            .b(Box::new(b))
            .build()
            .into_diagnostic()?;
        let string_list_group_1_built =
            StringListGroup::StringListGroup1(string_list_group_1_built);
        self.push(ASTType::StringListGroup(string_list_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// StringListGroup: C;
    ///
    #[parol_runtime::function_name::named]
    fn string_list_group_2(
        &mut self,
        _c: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c = pop_item!(self, c, C, context);
        let string_list_group_2_built = StringListGroup2Builder::default()
            .c(Box::new(c))
            .build()
            .into_diagnostic()?;
        let string_list_group_2_built =
            StringListGroup::StringListGroup2(string_list_group_2_built);
        self.push(ASTType::StringListGroup(string_list_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// StringList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn string_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_list_1_built = Vec::new();
        self.push(ASTType::StringList(string_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// A: <String>/a/;
    ///
    #[parol_runtime::function_name::named]
    fn a(
        &mut self,
        a: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a = a.token(parse_tree)?.clone();
        let a_built = ABuilder::default().a(a).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.a(&a_built)?;
        self.push(ASTType::A(a_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// B: <String>/b/;
    ///
    #[parol_runtime::function_name::named]
    fn b(
        &mut self,
        b: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = b.token(parse_tree)?.clone();
        let b_built = BBuilder::default().b(b).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.b(&b_built)?;
        self.push(ASTType::B(b_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// C: <String>/c/;
    ///
    #[parol_runtime::function_name::named]
    fn c(
        &mut self,
        c: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c = c.token(parse_tree)?.clone();
        let c_built = CBuilder::default().c(c).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.c(&c_built)?;
        self.push(ASTType::C(c_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// StringWrapper: <String>/"/;
    ///
    #[parol_runtime::function_name::named]
    fn string_wrapper(
        &mut self,
        string_wrapper: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_wrapper = string_wrapper.token(parse_tree)?.clone();
        let string_wrapper_built = StringWrapperBuilder::default()
            .string_wrapper(string_wrapper)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.string_wrapper(&string_wrapper_built)?;
        self.push(ASTType::StringWrapper(string_wrapper_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolSandboxGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolSandboxGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_sandbox(&children[0], parse_tree),
            1 => self.string(&children[0], &children[1], &children[2], parse_tree),
            2 => self.string_list_0(&children[0], &children[1], parse_tree),
            3 => self.string_list_group_0(&children[0], parse_tree),
            4 => self.string_list_group_1(&children[0], parse_tree),
            5 => self.string_list_group_2(&children[0], parse_tree),
            6 => self.string_list_1(parse_tree),
            7 => self.a(&children[0], parse_tree),
            8 => self.b(&children[0], parse_tree),
            9 => self.c(&children[0], parse_tree),
            10 => self.string_wrapper(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
