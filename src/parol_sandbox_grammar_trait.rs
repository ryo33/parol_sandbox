// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolSandboxGrammarTrait<'t> {
    /// Semantic action for non-terminal 'Expr'
    fn expr(&mut self, _arg: &Expr<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'A'
    fn a(&mut self, _arg: &A<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'B'
    fn b(&mut self, _arg: &B<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'C'
    fn c(&mut self, _arg: &C<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 0
///
/// Expr: A B C;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expr0<'t> {
    pub a: Box<A<'t>>,
    pub b: Box<B<'t>>,
    pub c: Box<C<'t>>,
}

///
/// Type derived for production 1
///
/// Expr: '!' ExprOpt /* Option */ Expr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expr1<'t> {
    pub bang: Token<'t>, /* ! */
    pub expr_opt: Option<Box<ExprOpt<'t>>>,
    pub expr: Box<Expr<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal A
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct A<'t> {
    pub a: Token<'t>, /* a */
}

///
/// Type derived for non-terminal B
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct B<'t> {
    pub b: Token<'t>, /* b */
}

///
/// Type derived for non-terminal C
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct C<'t> {
    pub c: Token<'t>, /* c */
}

///
/// Type derived for non-terminal Expr
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expr<'t> {
    Expr0(Expr0<'t>),
    Expr1(Expr1<'t>),
}

///
/// Type derived for non-terminal ExprOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExprOpt<'t> {
    pub minus_g_t: Token<'t>, /* -> */
    pub expr: Box<Expr<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    A(A<'t>),
    B(B<'t>),
    C(C<'t>),
    Expr(Expr<'t>),
    ExprOpt(Option<Box<ExprOpt<'t>>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolSandboxGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolSandboxGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolSandboxGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// Expr: A B C;
    ///
    #[parol_runtime::function_name::named]
    fn expr_0(
        &mut self,
        _a: &ParseTreeStackEntry<'t>,
        _b: &ParseTreeStackEntry<'t>,
        _c: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c = pop_item!(self, c, C, context);
        let b = pop_item!(self, b, B, context);
        let a = pop_item!(self, a, A, context);
        let expr_0_built = Expr0Builder::default()
            .a(Box::new(a))
            .b(Box::new(b))
            .c(Box::new(c))
            .build()
            .into_diagnostic()?;
        let expr_0_built = Expr::Expr0(expr_0_built);
        // Calling user action here
        self.user_grammar.expr(&expr_0_built)?;
        self.push(ASTType::Expr(expr_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Expr: '!' ExprOpt /* Option */ Expr;
    ///
    #[parol_runtime::function_name::named]
    fn expr_1(
        &mut self,
        bang: &ParseTreeStackEntry<'t>,
        _expr_opt: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang = bang.token(parse_tree)?.clone();
        let expr = pop_item!(self, expr, Expr, context);
        let expr_opt = pop_item!(self, expr_opt, ExprOpt, context);
        let expr_1_built = Expr1Builder::default()
            .bang(bang)
            .expr_opt(expr_opt)
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        let expr_1_built = Expr::Expr1(expr_1_built);
        // Calling user action here
        self.user_grammar.expr(&expr_1_built)?;
        self.push(ASTType::Expr(expr_1_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ExprOpt /* Option<T>::Some */: '->' Expr;
    ///
    #[parol_runtime::function_name::named]
    fn expr_opt_0(
        &mut self,
        minus_g_t: &ParseTreeStackEntry<'t>,
        _expr: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t = minus_g_t.token(parse_tree)?.clone();
        let expr = pop_item!(self, expr, Expr, context);
        let expr_opt_0_built = ExprOptBuilder::default()
            .minus_g_t(minus_g_t)
            .expr(Box::new(expr))
            .build()
            .into_diagnostic()?;
        self.push(ASTType::ExprOpt(Some(Box::new(expr_opt_0_built))), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ExprOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expr_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExprOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// A: "a";
    ///
    #[parol_runtime::function_name::named]
    fn a(
        &mut self,
        a: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a = a.token(parse_tree)?.clone();
        let a_built = ABuilder::default().a(a).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.a(&a_built)?;
        self.push(ASTType::A(a_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// B: "b";
    ///
    #[parol_runtime::function_name::named]
    fn b(
        &mut self,
        b: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = b.token(parse_tree)?.clone();
        let b_built = BBuilder::default().b(b).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.b(&b_built)?;
        self.push(ASTType::B(b_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// C: "c";
    ///
    #[parol_runtime::function_name::named]
    fn c(
        &mut self,
        c: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c = c.token(parse_tree)?.clone();
        let c_built = CBuilder::default().c(c).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.c(&c_built)?;
        self.push(ASTType::C(c_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolSandboxGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolSandboxGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.expr_0(&children[0], &children[1], &children[2], parse_tree),
            1 => self.expr_1(&children[0], &children[1], &children[2], parse_tree),
            2 => self.expr_opt_0(&children[0], &children[1], parse_tree),
            3 => self.expr_opt_1(parse_tree),
            4 => self.a(&children[0], parse_tree),
            5 => self.b(&children[0], parse_tree),
            6 => self.c(&children[0], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
