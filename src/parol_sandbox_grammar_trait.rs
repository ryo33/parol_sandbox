// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait ParolSandboxGrammarTrait<'t> {
    /// Semantic action for non-terminal 'ParolSandbox'
    fn parol_sandbox(&mut self, _arg: &ParolSandbox<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 2
///
/// ParolSandboxListGroup: /a/;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandboxListGroup0<'t> {
    pub a: Token<'t>, /* a */
}

///
/// Type derived for production 3
///
/// ParolSandboxListGroup: /b/;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandboxListGroup1<'t> {
    pub b: Token<'t>, /* b */
}

///
/// Type derived for production 4
///
/// ParolSandboxListGroup: /c/;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandboxListGroup2<'t> {
    pub c: Token<'t>, /* c */
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal ParolSandbox
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandbox<'t> {
    pub parol_sandbox_list: Vec<ParolSandboxList<'t>>,
}

///
/// Type derived for non-terminal ParolSandboxList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParolSandboxList<'t> {
    pub parol_sandbox_list_group: Box<ParolSandboxListGroup<'t>>,
}

///
/// Type derived for non-terminal ParolSandboxListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ParolSandboxListGroup<'t> {
    ParolSandboxListGroup0(ParolSandboxListGroup0<'t>),
    ParolSandboxListGroup1(ParolSandboxListGroup1<'t>),
    ParolSandboxListGroup2(ParolSandboxListGroup2<'t>),
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    ParolSandbox(ParolSandbox<'t>),
    ParolSandboxList(Vec<ParolSandboxList<'t>>),
    ParolSandboxListGroup(ParolSandboxListGroup<'t>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct ParolSandboxGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `ParolSandboxGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> ParolSandboxGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn ParolSandboxGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// ParolSandbox: /"/^ /* Clipped */ %push(String) ParolSandboxList /* Vec */ /"/^ /* Clipped */ %pop();
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox(
        &mut self,
        _quote: &ParseTreeStackEntry<'t>,
        _parol_sandbox_list: &ParseTreeStackEntry<'t>,
        _quote0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_sandbox_list =
            pop_and_reverse_item!(self, parol_sandbox_list, ParolSandboxList, context);
        let parol_sandbox_built = ParolSandboxBuilder::default()
            // Ignore clipped member 'quote'
            .parol_sandbox_list(parol_sandbox_list)
            // Ignore clipped member 'quote0'
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parol_sandbox(&parol_sandbox_built)?;
        self.push(ASTType::ParolSandbox(parol_sandbox_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ParolSandboxList /* Vec<T>::Push */: ParolSandboxListGroup ParolSandboxList;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox_list_0(
        &mut self,
        _parol_sandbox_list_group: &ParseTreeStackEntry<'t>,
        _parol_sandbox_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut parol_sandbox_list = pop_item!(self, parol_sandbox_list, ParolSandboxList, context);
        let parol_sandbox_list_group = pop_item!(
            self,
            parol_sandbox_list_group,
            ParolSandboxListGroup,
            context
        );
        let parol_sandbox_list_0_built = ParolSandboxListBuilder::default()
            .parol_sandbox_list_group(Box::new(parol_sandbox_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        parol_sandbox_list.push(parol_sandbox_list_0_built);
        self.push(ASTType::ParolSandboxList(parol_sandbox_list), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ParolSandboxListGroup: /a/;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox_list_group_0(
        &mut self,
        a: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let a = a.token(parse_tree)?.clone();
        let parol_sandbox_list_group_0_built = ParolSandboxListGroup0Builder::default()
            .a(a)
            .build()
            .into_diagnostic()?;
        let parol_sandbox_list_group_0_built =
            ParolSandboxListGroup::ParolSandboxListGroup0(parol_sandbox_list_group_0_built);
        self.push(
            ASTType::ParolSandboxListGroup(parol_sandbox_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// ParolSandboxListGroup: /b/;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox_list_group_1(
        &mut self,
        b: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let b = b.token(parse_tree)?.clone();
        let parol_sandbox_list_group_1_built = ParolSandboxListGroup1Builder::default()
            .b(b)
            .build()
            .into_diagnostic()?;
        let parol_sandbox_list_group_1_built =
            ParolSandboxListGroup::ParolSandboxListGroup1(parol_sandbox_list_group_1_built);
        self.push(
            ASTType::ParolSandboxListGroup(parol_sandbox_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// ParolSandboxListGroup: /c/;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox_list_group_2(
        &mut self,
        c: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let c = c.token(parse_tree)?.clone();
        let parol_sandbox_list_group_2_built = ParolSandboxListGroup2Builder::default()
            .c(c)
            .build()
            .into_diagnostic()?;
        let parol_sandbox_list_group_2_built =
            ParolSandboxListGroup::ParolSandboxListGroup2(parol_sandbox_list_group_2_built);
        self.push(
            ASTType::ParolSandboxListGroup(parol_sandbox_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// ParolSandboxList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn parol_sandbox_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parol_sandbox_list_1_built = Vec::new();
        self.push(
            ASTType::ParolSandboxList(parol_sandbox_list_1_built),
            context,
        );
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for ParolSandboxGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item ParolSandboxGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.parol_sandbox(&children[0], &children[1], &children[2], parse_tree),
            1 => self.parol_sandbox_list_0(&children[0], &children[1], parse_tree),
            2 => self.parol_sandbox_list_group_0(&children[0], parse_tree),
            3 => self.parol_sandbox_list_group_1(&children[0], parse_tree),
            4 => self.parol_sandbox_list_group_2(&children[0], parse_tree),
            5 => self.parol_sandbox_list_1(parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
